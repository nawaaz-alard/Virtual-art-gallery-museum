<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Surreal Echoes → Infinite Archive (3D)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--void:#0b0b1a;--accent:#ff2af5;--gold:#d4af37;--text:#e0e0ff;}
  html,body{height:100%;margin:0;background:var(--void);color:var(--text);font-family:Georgia,serif;}
  header{padding:2rem;text-align:center;background:linear-gradient(to bottom,#1a0033,transparent);}
  h1{color:var(--accent);margin:0 0 .25rem;text-shadow:0 0 20px #ff2af5;font-size:2.6rem;}
  p.sub{margin:0;color:rgba(224,224,255,0.9)}
  .page{max-width:1200px;margin:1rem auto;padding:1rem;}
  /* Canvas container for Three.js scene */
  #three-container{width:100%;height:70vh;border-radius:12px;overflow:hidden;box-shadow:0 0 80px rgba(255,42,245,0.06);border:1px solid rgba(255,42,245,0.06);cursor:pointer;background:#000;}
  .ui-instructions{padding:.75rem 1rem;background:linear-gradient(90deg,rgba(10,10,20,0.9),rgba(10,5,20,0.85));margin:.75rem 0;border-radius:10px;color:var(--gold);}
  .controls{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;}
  .controls .kbd{background:#111;padding:.25rem .6rem;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-weight:bold;color:var(--text);}

  /* modal (reuse your original style, slightly adapted) */
  .modal{display:none;position:fixed;z-index:9999;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.85);
    align-items:center;justify-content:center;}
  .modal-content{background:#0f0f12;padding:2rem;max-width:720px;border:2px solid var(--accent);border-radius:12px;color:var(--text);box-shadow:0 0 60px #ff2af5;}
  .close{float:right;font-size:2rem;cursor:pointer;color:#fff}
  .small{font-size:0.9rem;color:#ccc;margin-top:.75rem;}

  /* simple responsive */
  @media (max-width:700px){
    #three-container{height:55vh;}
    h1{font-size:1.9rem;}
  }
</style>
</head>
<body>

<header>
  <h1>Surreal Echoes — Infinite Archive</h1>
  <p class="sub">Click the black box below to enter the 3D museum. WASD to move, mouse to look, click or press <strong>E</strong> to interact.</p>
</header>

<div class="page">
  <!-- Keep your original gallery or other content above/around the museum as you like -->
  <div id="gallery-preview" style="margin-bottom:1rem;">
    <h2 style="color:var(--gold)">Gallery Preview (2D)</h2>
    <p class="small">The surreal gallery remains intact above; scroll to experience the original rooms. The 3D museum is below.</p>
  </div>

  <div id="three-container" title="Click to enter the museum (pointer lock)">
    <!-- Three.js renderer will be injected here -->
    <canvas id="three-canvas"></canvas>
  </div>

  <div class="ui-instructions">
    <div class="controls">
      <div class="kbd">W</div><div class="kbd">A</div><div class="kbd">S</div><div class="kbd">D</div> — move
      &nbsp; · &nbsp; Mouse — look
      &nbsp; · &nbsp; Click or <span class="kbd">E</span> — interact / open exhibit
      &nbsp; · &nbsp; <span class="kbd">Esc</span> — release pointer lock
    </div>
  </div>
</div>

<!-- Modal that shows exhibit info (reused style) -->
<div id="modal" class="modal" onclick="this.style.display='none'">
  <div class="modal-content" onclick="event.stopPropagation()">
    <span class="close" onclick="document.getElementById('modal').style.display='none'">×</span>
    <h2 id="modal-title"></h2>
    <p id="modal-desc"></p>
    <p class="small">Click outside to close.</p>
  </div>
</div>

<!-- Load Three.js modules from CDN -->
<script type="module">
/* ===== Three.js 3D museum walkthrough (medium complexity) =====
   - Uses Three.js ES modules from unpkg
   - PointerLockControls for mouse-look + WASD movement
   - Simple rooms composed of boxes; exhibits are textured planes
   - Raycaster for interactions (click or press 'E')
   - Canvas textures used for exhibit labels so content is editable
*/

import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/PointerLockControls.js';

const container = document.getElementById('three-container');
const canvas = document.getElementById('three-canvas');

// Renderer
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
container.appendChild(renderer.domElement);

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x05040a);

// Camera
const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.set(0, 1.6, 6);

// Lights
const hemi = new THREE.HemisphereLight(0xffffee, 0x080820, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffaaff, 0.6);
dir.position.set(5,10,7);
scene.add(dir);

// Controls
const controls = new PointerLockControls(camera, renderer.domElement);
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let canMove=false;
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const speed = 5; // units per second

// Pointer lock activation by clicking the container
container.addEventListener('click', () => {
  controls.lock();
});

// When pointer lock is active
controls.addEventListener('lock', () => { canMove = true; container.style.cursor='none'; });
controls.addEventListener('unlock', () => { canMove = false; container.style.cursor='pointer'; });

// Add a simple floor grid for orientation
const floorGeo = new THREE.PlaneGeometry(100,100);
const floorMat = new THREE.MeshStandardMaterial({ color:0x080820, roughness:0.9, metalness:0.1 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.y = 0;
scene.add(floor);

// Create simple room modules (boxes) with textured exhibit panels
const exhibits = []; // store exhibit objects for interaction

function makeExhibitPanel(title, subtitle, w=1.8, h=1.0){
  // create a canvas texture with label
  const cx = document.createElement('canvas');
  cx.width = 1024; cx.height = 512;
  const ctx = cx.getContext('2d');
  // background
  ctx.fillStyle = '#0b0b1a';
  ctx.fillRect(0,0,cx.width,cx.height);
  // accent bar
  ctx.fillStyle = '#ff2af5';
  ctx.fillRect(0,0,cx.width,60);
  // title
  ctx.font = 'bold 56px Georgia, serif';
  ctx.fillStyle = '#d4af37';
  ctx.textAlign = 'left';
  ctx.fillText(title, 30, 120);
  // subtitle
  ctx.font = '26px Georgia, serif';
  ctx.fillStyle = '#e0e0ff';
  wrapText(ctx, subtitle, 30, 170, 960, 34);
  // border glow
  // no real glow but set emissive in material
  const tex = new THREE.CanvasTexture(cx);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  const mat = new THREE.MeshStandardMaterial({ map:tex, emissive:0x2b0632, emissiveIntensity:0.08 });
  const geo = new THREE.PlaneGeometry(w, h);
  const mesh = new THREE.Mesh(geo, mat);
  return { mesh, title, desc:subtitle };
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      ctx.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, y);
}

// Helper: create a simple room (floor + 4 walls) and place exhibits on walls
function createRoom(cx, cz, roomWidth=6, roomDepth=8, roomHeight=3){
  const roomGroup = new THREE.Group();
  roomGroup.position.set(cx, 0, cz);

  const wallMat = new THREE.MeshStandardMaterial({ color:0x0e0620, side:THREE.BackSide, roughness:0.9 });
  const roomGeo = new THREE.BoxGeometry(roomWidth, roomHeight, roomDepth);
  const roomMesh = new THREE.Mesh(roomGeo, wallMat);
  roomMesh.position.y = roomHeight/2;
  // Invert the box to make interior visible: use BackSide above
  roomGroup.add(roomMesh);

  // subtle ambient plane lights for the room
  const pLight = new THREE.PointLight(0xff88ff, 0.12, 20);
  pLight.position.set(0, roomHeight-0.5, 0);
  roomGroup.add(pLight);

  scene.add(roomGroup);
  return roomGroup;
}

// Place several rooms and exhibits
const layout = [
  { x: -12, z: 0, name: 'Hall of Ancient Wonders', items: [
    ['Rosetta Stone Replica','Translates itself into ancient memes'],
    ['Nefertiti’s VR Crown','4K afterlife tours']
  ]},
  { x: 0, z: 0, name: 'Quantum Curiosities', items: [
    ['Schrödinger’s Music Box','Plays a melody that only exists if you don’t listen'],
    ['The Particle That Remembers You','Glows brighter when you think about it'],
    ['Broken Light Cone','A sculpture where time bends visibly around it']
  ]},
  { x: 12, z: 0, name: 'Chrono-Artifacts Vault', items: [
    ['Backwards Clock','Finishes before it starts'],
    ['Liquid Time Hourglass','Moves slower when you’re watching'],
    ['Dreamwatch','Ticks only in dreams']
  ]},
  { x: 0, z: -12, name: 'Mythical Zoology Annex', items:[
    ['Phoenix Feather','Frozen mid-rebirth, gently vibrating'],
    ['Mermaid’s Voice Crystal','Stored inside a crystal—sounds like distant tides'],
    ['Unicorn Footprint Cast','Glows under moonlight only']
  ]}
];

for(const cell of layout){
  const room = createRoom(cell.x, cell.z, 8, 10, 3.2);

  // Add a sign / headline floating near entrance
  const sign = makeExhibitPanel(cell.name, cell.name + ' — walk around and interact', 2.4, 0.8);
  sign.mesh.position.set(cell.x, 1.6, cell.z - 4.4); // front of room
  sign.mesh.lookAt(camera.position);
  scene.add(sign.mesh);
  exhibits.push({ obj: sign.mesh, title: sign.title, desc: sign.desc });

  // Add exhibits along the walls
  const items = cell.items;
  for(let i=0;i<items.length;i++){
    const [title,desc] = items[i];
    const ex = makeExhibitPanel(title, desc, 1.8, 1.0);
    // position them along one side wall or other
    const side = (i % 2 === 0) ? 1 : -1;
    const offset = (i*2) - ((items.length-1)*1);
    ex.mesh.position.set(cell.x + side*3.5, 1.6, cell.z + offset);
    ex.mesh.rotation.y = side === 1 ? -Math.PI/2 : Math.PI/2; // face inward
    scene.add(ex.mesh);
    exhibits.push({ obj: ex.mesh, title: ex.title, desc: ex.desc });
  }
}

// Add some roaming floating particles (ambience)
const particleGeo = new THREE.BufferGeometry();
const count = 120;
const positions = new Float32Array(count*3);
for(let i=0;i<count;i++){
  positions[i*3] = (Math.random()-0.5)*30;
  positions[i*3+1] = Math.random()*6+0.5;
  positions[i*3+2] = (Math.random()-0.5)*30;
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const particleMat = new THREE.PointsMaterial({ size: 0.04, color: 0xff66ff, opacity:0.9, transparent:true });
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

// Raycaster for interactions
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Interaction helpers
function openExhibit(title,desc){
  const modal = document.getElementById('modal');
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-desc').textContent = desc;
  modal.style.display = 'flex';
  // unlock pointer so user can interact with modal
  controls.unlock();
}

function getIntersectedExhibit(screenX, screenY){
  // screenX/Y in normalized device coords [-1,1] or pixel coords? we'll use pixel coords
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((screenX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((screenY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const objs = exhibits.map(e=>e.obj);
  const hits = raycaster.intersectObjects(objs, false);
  if(hits.length>0) return hits[0].object;
  return null;
}

renderer.domElement.addEventListener('click', (ev) => {
  // if pointer lock not active, clicking already locks; if active, try to interact
  if(!controls.isLocked) return;
  const hit = getIntersectedExhibit(ev.clientX, ev.clientY);
  if(hit){
    const ex = exhibits.find(e => e.obj === hit);
    if(ex) openExhibit(ex.title, ex.desc);
  }
});

// Allow 'E' key to interact with whatever is in front within small distance
document.addEventListener('keydown', (e) => {
  if(e.code === 'KeyE'){
    // cast a short ray forward from camera
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    raycaster.set(camera.position, forward);
    const hits = raycaster.intersectObjects(exhibits.map(x=>x.obj), true);
    if(hits.length>0 && hits[0].distance < 3.0){
      const ex = exhibits.find(ev => ev.obj === hits[0].object);
      if(ex) openExhibit(ex.title, ex.desc);
    }
  }
  if(e.code === 'KeyW') moveForward = true;
  if(e.code === 'KeyS') moveBackward = true;
  if(e.code === 'KeyA') moveLeft = true;
  if(e.code === 'KeyD') moveRight = true;
});

document.addEventListener('keyup', (e) => {
  if(e.code === 'KeyW') moveForward = false;
  if(e.code === 'KeyS') moveBackward = false;
  if(e.code === 'KeyA') moveLeft = false;
  if(e.code === 'KeyD') moveRight = false;
});

// Animate
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  prevTime = time;

  // gentle particle motion
  particles.rotation.y += delta * 0.02;

  if(canMove){
    // movement physics
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    direction.z = (moveForward ? 1 : 0) - (moveBackward ? 1 : 0);
    direction.x = (moveRight ? 1 : 0) - (moveLeft ? 1 : 0);
    direction.normalize();

    if(moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
    if(moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

    // translate camera via controls.getObject()
    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);
  }

  // keep camera above floor
  if(camera.position.y < 1.6) camera.position.y = 1.6;

  renderer.render(scene, camera);
}
animate();

// Resize handling
window.addEventListener('resize', onWindowResize, false);
function onWindowResize(){
  renderer.setSize(container.clientWidth, container.clientHeight);
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
}

// Basic ambient background subtle animation (color shift)
let hueTick = 0;
setInterval(()=> {
  hueTick += 0.02;
  const color = new THREE.Color().setHSL(0.85 + Math.sin(hueTick)*0.02, 0.25, 0.03);
  scene.background = color;
}, 120);

// Utility: when modal is opened, show unlock hint (modal handles unlocking via close)
document.getElementById('modal').addEventListener('click', () => {
  document.getElementById('modal').style.display='none';
});

</script>

</body>
</html>
